
---------------------------------------------
-- Extensions to the table table.
---------------------------------------------

local _DestroyedMetatableMsg = function(self, _)
    error(self.___Message or "Attemped to index a destroyed table")
end
local _DestroyedMetatable = {
    __index = _DestroyedMetatableMsg,
    __newindex = _DestroyedMetatableMsg,
}

---Sorts a table using the comparison operators on all values.
---@param tbl table Will be mutated.
---@param reverse boolean? Defaults to false.
---@return table Same table as the one passed by parameter (mutates in-place).
function table.simpleSort(tbl, reverse)
    local fun

    if reverse then
        fun = function(a, b) return a > b end
    else
        fun = function(a, b) return a < b end
    end

    table.sort(tbl, fun)

    return tbl
end

---Returns whether a table contains no keys.
---@param tbl table
---@return boolean
function table.isempty(tbl)
    local empty = true

    for _,_ in pairs(tbl) do
        empty = false
        break
    end

    return empty
end

---Sorts a an array of tables based on a property. The property must be a key in all tables contained in the array.
---@param tbl table
---@param prop string Property name.
---@param reverse boolean? Defaults to false.
---@return table -- Same table as the one passed by parameter (mutates in-place).
function table.sortByProperty(tbl, prop, reverse)
    local fun

    if reverse then
        fun = function(a, b) return a[prop] > b[prop] end
    else
        fun = function(a, b) return a[prop] < b[prop] end
    end

    table.sort(tbl, fun)

    return tbl
end

---Returns a new table with the keys and values swapped.
---@param tbl table
---@return table
function table.swap(tbl)
    local newTable = {}
    for k,v in pairs(tbl) do
        newTable[v] = k
    end
    return newTable
end

---Sorts an array of Describables by their name. TODO move to a static method of the interface
---@param tbl I_Describable[]
function table.sortByName(tbl)
    local fun = function(a, b) return a:GetName() < b:GetName() end

    table.sort(tbl, fun)

    return tbl
end

---Copies a table's values recursively, including metatables.
---From http://lua-users.org/wiki/CopyTable
---@param orig table
---@return table
function table.deepCopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[table.deepCopy(orig_key)] = table.deepCopy(orig_value)
        end
        setmetatable(copy, table.deepCopy(getmetatable(orig)))
    else -- primitives
        copy = orig
    end
    return copy
end

---Returns a new table with the first depth's elements copied.
---@param tbl table
---@return table
function table.shallowCopy(tbl)
    local newTable = {}

    for k,v in pairs(tbl) do
        newTable[k] = v
    end

    return newTable
end

---Similar to unpack, but respects "holes" in the array generated by select()
---@param p table
---@param l integer? Max length.
---@param i integer? Starting index. Defaults to 1.
---@return ... any
function table.unpackSelect(p, l, i)
    i = i or 1
    l = l or p.n -- Tables created by select() have this key as "length".

    if l == 0 then
        return
    elseif i == l then
        return p[i]
    else
        return p[i], table.unpackSelect(p, l, i + 1)
    end
end

---Returns the first index that maps to the passed value.
---@param table1 table
---@param value any
---@return any
function table.reverseLookup(table1, value)
    for i,v in pairs(table1) do
        if v == value then
            return i
        end
    end
    return nil
end

---Returns whether the table contains the passed value. Does **not** search recursively.
---@param tbl table
---@param value any
---@return boolean
function table.contains(tbl, value)
    for _,val in pairs(tbl) do
        if val == value then
            return true
        end
    end

    return false
end

---Count the amount of keys in a table.
---@param t table
---@return integer Key count.
function table.getKeyCount(t)
    local count = 0

    for _,_ in pairs(t) do
        count = count + 1
    end

    return count
end

---Returns a new list with entries filtered based on a predicate.
---@generic T
---@param list T[]
---@param predicate fun(item:T):boolean Should return true for items to be included in the new list.
---@return T[]
function table.filter(list, predicate)
    local newList = {}

    for _,item in ipairs(list) do
        if predicate(item) then
            table.insert(newList, item)
        end
    end

    return newList
end

---Converts a list of elements to a set-like table.
---@generic T
---@param list T[]
---@return table<T, true>
function table.listtoset(list)
    local set = {}
    for _,id in ipairs(list) do
        set[id] = true
    end
    return set
end

---Returns the first key-value pair that matches a predicate.
---@generic K, V
---@param tbl table<K, V>
---@param predicate fun(k:K, v:V):boolean Should return `true` for the first pair to be returned.
---@return K, V
function table.getFirst(tbl, predicate)
    local firstK, firstV = nil, nil

    for k,v in pairs(tbl) do
        if predicate(k, v) then
            firstK = k
            firstV = v
            break
        end
    end

    return firstK, firstV
end

---Recursively copies the table onto a new one calling pairs() to get all values,
---without metatables nor keys that are skipped by any custom __pairs() or __ipairs() implementation.
---@param t table
---@return table
function table.clean(t)
    local tbl = {}

    for k,v in pairs(t) do
        if type(v) == "table" then
            v = table.clean(v)
        end

        tbl[k] = v
    end

    return tbl
end

---Creates a new array by inserting elements from t1 and t2 in order.
---@param t1 any[]
---@param t2 any[]
---@return any[]
function table.join(t1, t2)
    local result = {}

    for _,value in ipairs(t1) do
        table.insert(result, value)
    end
    for _,value in ipairs(t2) do
        table.insert(result, value)
    end

    return result
end

---Makes a table reference unusable,
---by removing all its keys and setting
---the metatable to throw an error on index.
---@param tbl table
---@param msg string? Error message to show upon attempting to index the table. Defaults to `"Attemped to index a destroyed table"`
function table.destroy(tbl, msg)
    setmetatable(tbl, nil) -- Required to avoid an error in C++ side
    for k,_ in pairs(tbl) do -- Setting fields to nil while iterating *should* be fine according to next() documentation
        tbl[k] = nil
    end
    tbl.___Message = msg
    setmetatable(tbl, _DestroyedMetatable)
end

---Returns whether `table.destroy()` has been run on a table.
---@param tbl table
---@return boolean
function table.isdestroyed(tbl)
    return getmetatable(tbl) == _DestroyedMetatable
end