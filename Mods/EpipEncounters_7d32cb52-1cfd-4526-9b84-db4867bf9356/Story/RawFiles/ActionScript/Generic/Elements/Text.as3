package Elements
{
    import LS_Classes.LSPanelHelpers;
    import LS_Classes.textEffect;
    import flash.display.MovieClip;
    import flash.external.ExternalInterface;
    import LS_Classes.listDisplay;
    import flash.text.TextField;
    import flash.events.MouseEvent;
    import flash.events.Event;
    import flash.events.FocusEvent;
    import flash.events.KeyboardEvent;
    import flash.text.TextFormat;

    public dynamic class Text extends Element
    {
        public var text_txt:TextField;

        public var _txt_Left:TextField;
        public var _txt_Center:TextField;
        public var _txt_Right:TextField;

        public var _cachedText:String = "";
        private var _editable:Boolean = false;
        private var _mouseEnabled:Boolean = false;

        private var visualTypes:Object = null;

        public function Text()
        {
            super();
            this.visualTypes = new Object();

            this.RegisterTextType("Left", this._txt_Left);
            this.RegisterTextType("Center", this._txt_Center);
            this.RegisterTextType("Right", this._txt_Right);

            this.SetType("Center");
            this.SetMouseEnabled(this._mouseEnabled);

            this.SetEditable(false);
        }

        public override function get elementType() : String
        {
            return "Text";
        }

        public override function SetMouseEnabled(enabled) : *
        {
            this._mouseEnabled = enabled;

            this.mouseEnabled = enabled;
            this.text_txt.mouseEnabled = enabled;
        }

        private function RegisterTextType(stringID:String, txt:TextField) : *
        {
            var obj:Object = new Object();

            obj.TextField = txt;

            this.visualTypes[stringID] = obj;
            
            txt.visible = false;
            txt.width = 0;
            txt.height = 0;

            txt.addEventListener(Event.CHANGE,this.onChange);
            txt.addEventListener(FocusEvent.FOCUS_IN,this.onFocus, false, 0, true);
            txt.addEventListener(FocusEvent.FOCUS_OUT,this.onFocusLost, false, 0, true);

            var format:TextFormat = new TextFormat();
            format.color = 0xffffff
            txt.defaultTextFormat = format;

            this.removeChild(txt);
        }

        public function SetType(txtType:String) : *
        {
            var data:Object = this.visualTypes[txtType];

            if (data)
            {
                if (this.text_txt)
                {
                    this.removeChild(this.text_txt);
                }

                this.text_txt = data.TextField;
                this.addChild(this.text_txt);

                this.text_txt.visible = true;

                this.SetText(this._cachedText);
                this.SetEditable(this._editable);
                this.SetMouseEnabled(this._mouseEnabled);
            }
            else
            {
                this.Log("SetType(): invalid type " + txtType, 2);

                this.SetType("Center");
            }
        }

        public function SetText(text:String, setSize:Boolean=false) : *
        {
            this.text_txt.htmlText = text;
            this._cachedText = text;

            if (setSize)
            {
                this.SetSize(this.text_txt.textWidth, this.text_txt.textHeight);
            }
        }

        public function SetEditable(editable:Boolean) : *
        {
            this.text_txt.selectable = editable;

            this._editable = editable;

            if (!editable)
            {
                this.text_txt.restrict = "";
            }
            else // Setting a field to be editable also turns on mouse events.
            {
                this.SetMouseEnabled(true);
            }
        }

        public function SetRestrictedCharacters(restriction:String) : *
        {
            this.text_txt.restrict = restriction;
        }

        public override function SetSize(width:Number, height:Number) : *
        {
            this.text_txt.width = width;
            this.text_txt.height = height;
        }

        public function AddStroke(color:uint, size:Number, alpha:Number = 1.0, strength:uint = 1, p5:uint = 2) : *
        {
            this.text_txt.filters = textEffect.createStrokeFilter(color, size, alpha, strength, p5);
        }

        // lineIndex param is 1-based.
        public function GetLineHeight(lineIndex:uint) : Number
        {
            return this.text_txt.getLineMetrics(lineIndex - 1).height;
        }

        // lineIndex param is 1-based.
        public function GetLineWidth(lineIndex:uint) : Number
        {
            return this.text_txt.getLineMetrics(lineIndex - 1).width;
        }

        private function acceptSave() : *
        {
            var _loc1_:String = this.text_txt.text;

            _loc1_ = this.strReplace(_loc1_,"\n","");
            _loc1_ = this.strReplace(_loc1_,"\r","");
            _loc1_ = this.strReplace(_loc1_,"\t","");

            this._cachedText = _loc1_;

            ExternalInterface.call("Text_Changed", this.stringID, _loc1_);
        }
        
        private function onChange(param1:Event) : *
        {
            if (!this._editable)
            {
                this.text_txt.htmlText = this._cachedText;
            }
            else
            {
                this.acceptSave();
            }
        }
        
        private function onFocus(param1:FocusEvent) : *
        {
            if (this._editable)
            {
                var base:MovieClip = root as MovieClip;

                this.text_txt.addEventListener(KeyboardEvent.KEY_DOWN, this.inputHandler);
                ExternalInterface.call("inputFocus");

                base.focusedElement = this; // TODO remove?

                ExternalInterface.call("Text_Focused", this.stringID);
            }
        }
        
        private function onFocusLost(param1:FocusEvent) : *
        {
            this.text_txt.removeEventListener(KeyboardEvent.KEY_DOWN, this.inputHandler);
            ExternalInterface.call("inputFocusLost");

            ExternalInterface.call("Text_Unfocused", this.stringID);
        }
        
        private function strReplace(param1:String, param2:String, param3:String) : String
        {
            return param1.split(param2).join(param3);
        }
        
        private function inputHandler(param1:KeyboardEvent) : *
        {
            this.acceptSave();

            if(param1.charCode == 13)
            {
                ExternalInterface.call("inputFocusLost");
                stage.focus = null;
            }
        }

        // TODO setfont
    }
}
